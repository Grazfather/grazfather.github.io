<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>re on Grazfather</title>
    <link>https://grazfather.github.io/tags/re/</link>
    <description>Recent content in re on Grazfather</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Sun, 08 Dec 2019 12:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://grazfather.github.io/tags/re/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Glitching the Olimex LPC-P1343</title>
      <link>https://grazfather.github.io/posts/2019-12-08-glitcher/</link>
      <pubDate>Sun, 08 Dec 2019 12:00:00 +0000</pubDate>
      
      <guid>https://grazfather.github.io/posts/2019-12-08-glitcher/</guid>
      <description>Back in the summer I was lucky enough to finagle my boss into letting me take Dmitry Nedospasov (@nedos)&amp;rsquo;s hardware hacking training. In it I cut my teeth on using an FPGA to interface with target hardware. After implementing a UART we implemented a module that could parse part of Apple&amp;rsquo;s OneWire, used to negotiate power exchange, among other things, with your iPhone over the lightning cable. Our &amp;lsquo;final project&amp;rsquo; was to build a UART-controllable glitcher, using it to try to glitch a development board.</description>
    </item>
    
    <item>
      <title>Microcorruption Hollywood</title>
      <link>https://grazfather.github.io/posts/2018-11-24-microcorruption-hollywood/</link>
      <pubDate>Sat, 24 Nov 2018 12:00:00 +0000</pubDate>
      
      <guid>https://grazfather.github.io/posts/2018-11-24-microcorruption-hollywood/</guid>
      <description>I&amp;rsquo;m a few years late to the party here, but I&amp;rsquo;ve recently managed to finish Microcorruption. I had finished most of the challenges back in 2014, when they were released, but not having IDA back then, I was stumped when the first challenge that relocated showed up, because it broke the online disassembler, and I was helpless without it :).
I recently took another look, having picked up some skill and knowledge in the intervening years.</description>
    </item>
    
    <item>
      <title>Plaid CTF 2018 coconut</title>
      <link>https://grazfather.github.io/posts/2018-05-06-plaid2018-coconut/</link>
      <pubDate>Sun, 06 May 2018 12:00:00 +0000</pubDate>
      
      <guid>https://grazfather.github.io/posts/2018-05-06-plaid2018-coconut/</guid>
      <description>First we&amp;rsquo;re given an address to connect to. Upon connecting with nc we see a bunch of (AT&amp;amp;T ðŸ¤®) x86_64 assembly, and we are told to delete lines to get under a certain threshold without changing the return value. Easy enough! I backtrack from the last write to eax and trace back until I see its final immediate value being written to the stack. Submit those lines, easy flag.
Let&amp;rsquo;s look at an example:</description>
    </item>
    
    <item>
      <title>RHME3 Quals - Whitebox</title>
      <link>https://grazfather.github.io/posts/2017-09-03-rhme3-quals-whitebox/</link>
      <pubDate>Sun, 03 Sep 2017 12:00:00 +0000</pubDate>
      
      <guid>https://grazfather.github.io/posts/2017-09-03-rhme3-quals-whitebox/</guid>
      <description>Crypto is certainly not my specialty but this is an &amp;lsquo;automotive ctf&amp;rsquo;, and working in the industry it became a pride point for me to solve this.
You&amp;rsquo;re provided a binary that reads 16 bytes of input and encrypts it with a hardcoded key. It doesn&amp;rsquo;t take a lot of looking at it to recognize that it&amp;rsquo;s (probably) AES. You can, for example, provide shorter input and see that the output is 16 bytes regardless, or change only one byte and see that the entire output changes, to prove that it&amp;rsquo;s a block cipher.</description>
    </item>
    
    <item>
      <title>Qiwi CTF 2016 - RE300_3</title>
      <link>https://grazfather.github.io/posts/2016-11-18-qiwictf-re300_3/</link>
      <pubDate>Fri, 18 Nov 2016 12:00:00 +0000</pubDate>
      
      <guid>https://grazfather.github.io/posts/2016-11-18-qiwictf-re300_3/</guid>
      <description>This challenge provided task.bin an ELF.
task.bin: ELF 32-bit LSB executable, Atmel AVR 8-bit, version 1 (SYSV), statically linked, not stripped Whoa! AVR! Lucky for us it&amp;rsquo;s 1. an ELF and 2. not stripped.
Popping it into IDA and manually selecting &amp;ldquo;Atmel AVR&amp;rdquo; as the CPU I was happy to see demangled C++ function names as well as global symbols. Looking at the globals there were a few of note: i, int_recorded, buttonState, and Serial.</description>
    </item>
    
    <item>
      <title>Manual Unpacking</title>
      <link>https://grazfather.github.io/posts/2016-11-06-manual-unpacking/</link>
      <pubDate>Sun, 06 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>https://grazfather.github.io/posts/2016-11-06-manual-unpacking/</guid>
      <description>While packers&amp;rsquo; original intention is to minimize the size of a binary, they are often used today as an &amp;lsquo;easy&amp;rsquo; form of obfuscation, making us reverse engineers&amp;rsquo; lives more difficult. In order to get around them it&amp;rsquo;s important to understand how they work in practice first.
Since writing an application that is intended to be packed is a pain the ass, packing is usually done as a separate step, and most packers can work basically agnostic of the content of what it&amp;rsquo;s packing.</description>
    </item>
    
    <item>
      <title>Obfuscation Techniques</title>
      <link>https://grazfather.github.io/posts/2016-10-12-obfuscation-techniques/</link>
      <pubDate>Wed, 12 Oct 2016 12:00:00 +0000</pubDate>
      
      <guid>https://grazfather.github.io/posts/2016-10-12-obfuscation-techniques/</guid>
      <description>I don&amp;rsquo;t know where I got these notes from, but I found them on my evernote and I thought they were worth exporting here.
Data-based obfuscation  Constant Unfolding  A compiler would do something like replace x = 4 * 5 with x = 20. This does the opposite.  e.g. push 0F9CBE47ah, add dword ptr [esp], 6341B86h. This is effectively push 0h.     Dead Code Insertion  Simply add code that has no effect but wastes the reverse engineer&amp;rsquo;s time.</description>
    </item>
    
    <item>
      <title>Anti-Debugging Techniques and Mitigation</title>
      <link>https://grazfather.github.io/posts/2016-09-18-anti-debugging/</link>
      <pubDate>Sun, 18 Sep 2016 12:00:00 +0000</pubDate>
      
      <guid>https://grazfather.github.io/posts/2016-09-18-anti-debugging/</guid>
      <description>Techniques   Windows
 API methods:  IsDebuggerPresent CheckRemoteDebuggerPresent NtQueryInformationProcess OutputDebugString/GetLastError   Manually checking structures  Check BeingDebugged in PEB (in fs:[30]). Check ForceFlags:  In fs:[30][18][10] on Windows XP. In fs:[30][18][44] on Windows 7 32 bit.   Check Flags:  In fs:[30][18][0C] on Windows XP. In fs:[30][18][40] on Windows 7 32 bit.   Check NTGlobalFlag at fs:[30][68] == 0x70. Look for debuggers specifically:  Check registry.</description>
    </item>
    
    <item>
      <title>Anti-Disassembly Techniques and Mitigation</title>
      <link>https://grazfather.github.io/posts/2016-09-18-anti-disassembly/</link>
      <pubDate>Sun, 18 Sep 2016 12:00:00 +0000</pubDate>
      
      <guid>https://grazfather.github.io/posts/2016-09-18-anti-disassembly/</guid>
      <description>This is just a small collection of notes about disassembly and anti-disassembly tricks, and how to get around them.
How disassemblers work The simplest disassembler is super simple, but they can also be very complicated. More advanced disassemblers try to recognize things like functions (which may have multiples returns), idioms like jump tables, and not get tricked by anti-disassembly tricks. They come in two general categories.
 Linear - Dissassembles all instructions in order, starting from some point (usually the entry point of a binary).</description>
    </item>
    
    <item>
      <title>Practical Malware Analysis Labs</title>
      <link>https://grazfather.github.io/posts/2016-09-11-practical-malware-analysis/</link>
      <pubDate>Sun, 11 Sep 2016 12:00:00 +0000</pubDate>
      
      <guid>https://grazfather.github.io/posts/2016-09-11-practical-malware-analysis/</guid>
      <description>I owe Practical Malware Analysis for kickstarting my career in security. Before reading it (and getting into CTFs) I was working as an embedded systems developer, and then a developer at a bug bounty company.
PMA has got to be the best technical book I&amp;rsquo;ve ever read. On the OpenToAll slack it&amp;rsquo;s the book I&amp;rsquo;m mostly likely to recommend, and that&amp;rsquo;s what I am doing here. I&amp;rsquo;ve worked through every lab in the book, currently available on my github.</description>
    </item>
    
    <item>
      <title>Google CTF - Mobile 150 - Ill Intentions</title>
      <link>https://grazfather.github.io/posts/2016-05-02-google-ctf-mobile-150-ill-intentions/</link>
      <pubDate>Mon, 02 May 2016 12:00:00 +0000</pubDate>
      
      <guid>https://grazfather.github.io/posts/2016-05-02-google-ctf-mobile-150-ill-intentions/</guid>
      <description>The timing for this challenge was just about perfect for me. A new colleague of mine just last week did a presentation on smali basics and debugging Android Applications using IDA. Before that I had only done some of the most basic patches in smali and no real dynamic stuff other than with am or purpose-built apps.
My process for an APK is pretty simple: Unzip, dex2jar, and apktool -d. This yields a .</description>
    </item>
    
    <item>
      <title>Sharif CTF 2016 - RE100 â€˜Android Appâ€™ Writeup</title>
      <link>https://grazfather.github.io/posts/2016-02-14-sharif-ctf-re100-android-app-writeup/</link>
      <pubDate>Sun, 14 Feb 2016 15:00:00 +0000</pubDate>
      
      <guid>https://grazfather.github.io/posts/2016-02-14-sharif-ctf-re100-android-app-writeup/</guid>
      <description>This one I didn&amp;rsquo;t actually solve in time, because I spent too much time trying to a) Use frida and b) RE the args to the two import functions.
Because I am a fan of Frida (first cutting my teeth on it during the 2015 Flare On challenge), I decided I would use it in lieu of a debugger for this challenge (I didn&amp;rsquo;t want to figure out the toolchain to get the lldb client running on my mac).</description>
    </item>
    
    <item>
      <title>Sharif CTF 2016 - RE150 â€˜Serialâ€™ Writeup</title>
      <link>https://grazfather.github.io/posts/2016-02-06-sharif-ctf-re150-serial-writeup/</link>
      <pubDate>Sat, 06 Feb 2016 17:04:23 +0000</pubDate>
      
      <guid>https://grazfather.github.io/posts/2016-02-06-sharif-ctf-re150-serial-writeup/</guid>
      <description>Starting out as I always do, I ran file, strings, etc, then ran in my VM in gdb and opened the binary in IDA Pro. The first thing I noticed is that IDA can&amp;rsquo;t view main in graph mode &amp;ndash; They are likely jumping around weird to trick disassemblers.
Looking in IDA, a few instruction into main there&amp;rsquo;s a jump back a few bytes, into the middle of another instruction &amp;ndash; suspicions confirmed.</description>
    </item>
    
  </channel>
</rss>