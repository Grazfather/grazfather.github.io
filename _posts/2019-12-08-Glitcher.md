---
layout: post
title:  "Glitching the Olimex LPC-P1343"
date:   2019-12-08 12:00:00 -0800
categories: re pwn electronics fpga
---

Back in the summer I was lucky enough to finagle my boss into letting me take Dmitry Nedospasov ([@nedos](https://twitter.com/nedos))'s [hardware hacking training](https://toothless.co/trainings/). In it I cut my teeth on using an FPGA to interface with target hardware. After implementing a UART we implemented a module that could parse part of Apple's OneWire, used to negotiate power exchange, among other things, with your iPhone over the lightning cable. Our 'final project' was to build a UART-controllable glitcher, using it to try to glitch a development board.

While we got it working, it was with a bit of hand-holding from Dmitry, including setting up the scope, the power supply etc. In an effort to concretize the knowledge, I decided when I got home that I wanted to do it again on my own.

If you haven't noticed, hobbyist FPGAs have flooded the market. There are now pretty good open source tool chains available for synthesizing, PNR, and simulation. I've played around with a few boards, and the [iCEBreaker](https://www.crowdsupply.com/1bitsquared/icebreaker-fpga) is my recent favourite. The people on their discord are super helpful, the toolchain is excellent, and the board itself is great for the price.

Porting it over wasn't too much work, the only real difference was that the FPGA we used in training was a Digilent Arty, which has a 100MHz clock, while the iCEBreaker's has a 12MHz. This requires we change anything that's counting cycles to account for the 8.33x slower clock, and we lose some granularity in anything we want to count. This is also an opportunity to generalize some of the code to not make as many assumptions about the FPGA it's running on. Because I was rusty, I chose to try to 'blindly' re-write some of the modules, instead of using the code Dmitry has on [his github](https://github.com/toothlessco/arty-glitcher).

# Background
A can't really give a better background to this than Dmitry does in his [blog post](https://toothless.co/blog/bootloader-bypass-part1/) about it. In short, when the target board boots up the bootROM reads the flash, and depending on the value it reads from address 0x2FC, and the state of a few pins, it determines whether the UART goes to a sort of shell, and whether you can use this shell to read out the flash. This is intended so that you can develop your firmware and debug in the bootloader, but then flash a version that sets this value when your firmware is production ready, hopefully preventing the end user from dumping it from the flash. The vulnerability here is that it's a 4 byte value, and only a specific value (0x12345678) will lock the bootloader in the expected way. That means that if any of the 32 bits read here are incorrect, the bootROM will consider the device unlocked. This is opposed to, for example, requiring a specific value to unlock the bootloader, and having the other 4 billion values lock it.

If we can get the CPU to misread the flash at the very moment it happens to be reading that value, then we can have it jump to the bootloader in the unlocked state. It's as easy as that! (Famous last words)

The idea here is that we will make the FPGA a tool that goes between my host machine and the target board. We can communicate with it using UART, and certain special bytes are interpreted as commands for the FPGA, while other values are simply passed through to the target board (to talk to its bootloader). The values sent back from the target board and simply passed directly through to the host machine. The FPGA supports configuring the delay between resetting the target board and pulsing a 'glitch voltage', and how long that glitch voltage lasts. It also supports sending multiple pulses, and of course can reset the target board and activate the glitch.

We use an FPGA here instead of a microcontroller for a few reasons:

* First, because we can configure things at the clock level, we can have very specific timing (1s/12000000 = 83.3ns precision).
* Second, for the same reason, we don't have to worry about jitter: With a raspberry PI we'd worry about the OS scheduling other process and such, contributing to inconsistency between runs. Even with an Arduino or other microcontroller, with no operating system, we'd have to worry about interrupts messing up the timing.
* Third, I wanted to get more practice using an FPGA.

# Setup
For the toolchain, I mostly took everything from WTFpga https://github.com/icebreaker-fpga/WTFpga, which is a beginner's lab that uses the iCEBreaker board. It uses [Yosys](https://github.com/YosysHQ/yosys), [nextpnr](https://github.com/YosysHQ/nextpnr), and a few tools from project [icestorm](https://github.com/cliffordwolf/icestorm). These are all open source tools that you can invoke from the command line, you don't need a GUI (so I don't need to run Vivado in a VM) and the time to build is _much, much_ faster than the few minutes it takes to get a synthesis to fail with obscure errors in Vivado. This really sped me up because I am not disciplined and instead of inspecting my code for errors ahead of time, I tend to compile, patch, and iterate until it builds.

For debugging I used pulseview (part of sigrok) when debugging real signals, and GTKwave to look at my simulated waveforms.

For hardware, I obviously used the iCEBreaker, as well as the [Olimex target board](https://www.olimex.com/Products/ARM/NXP/LPC-P1343/). My bench top supply is a DC50V5A, a cheap but handy configurable buck converter I got on Ali express. While I have a Saleae, I prefer Sigrok, and at the speeds I was running things at, a cheap 24MHz logic analyzer was enough. In the end I had some troubles debugging something using that alone and borrowed an oscilloscope, but in hindsight it wasn't necessary, just nice to have.

<pictures and bs>

# Design

Again, I am just porting over Dmitry's design, so here's the block drawing stolen from his blog:

![glitcher block diagram]({{site.url}}/assets/2019-12-08-glitching/glitcher_block_diagram.png)

The tl;dr is that the command module intercepts everything the host computer sends over UART. Based on the first byte it either interprets it as a command for the FPGA, or passes it through to the target. The resetter simply holds the reset down long enough for the target to reset (instead of one cycle), the delay module starts counting on reset and waits the configured number of cycles, the trigger module waits for the delay to finish and then tells the pulse module to send a pulse, and the pulse module is a lot like the delay module, except that it uses a different different config, and its output is connected to the power multiplexer.

This is all controlled by a python script that talks to the UART, first configuring the FPGA, then activating a glitch, and then communicating with the target. It determines whether it can read out the flag, and if it can't, it adjusts the delay and pulse width configs and tries again.

The FPGA has two inputs: The UART from the host, and the UART from the target board. It has 4 outputs: The UART to the host, the UART to the target board, a reset line to reset the target, and a `vout` that is used to control the analogue multiplexer, to quickly drop the voltage powering the target board.

# Testing

While you can certainly test on a real FPGA, it's very difficult to see what's going on inside the FPGA. You can blink LEDs, or, if you have the hardware, use seven segments displays to output whatever relevant value. I found this very handy and ended up buying a second just so that I could tell both my pulse width and delay count at a glance.

That said, even with the rather quick tools, flashing and debugging with a logic analyzer is a lot slower than ideal. I suggest setting up a good test bench and run simulations.

## Simulation
I used [Icarus Verilog](http://iverilog.icarus.com/) to simulate the various modules, and [GTKWave](http://gtkwave.sourceforge.net/) to look at the waveforms it generates. The basic idea is that you write extra verilog that simulates the inputs to your top module, and then verify that behaviour of the internal signals are as expected. As opposed to running on real hardware, it's easy to introspect any internal value any any point in time. You can also write test benches for any individual module, ensure that each part is behaving as expected before combining them together.

Here we see my simulation of the whole glitcher, I send a few configurations, and then some commands that should be passed through to the target.

![glitcher commands simulation]({{site.url}}/assets/2019-12-08-glitching/glitcher_testbench_cmds.png)

And here is what happens when the glitch command is sent. We see the reset line go down, then there is a delay based on the delay configuration we previously set, and the `vout` line goes low for a period of time determined by the pulse width configuration.

![glitcher pulse simulation]({{site.url}}/assets/2019-12-08-glitching/glitcher_testbench_pulse.png)

While a simulation is good, the real test is when you see it work on real hardware, which I was able to see here with my logic analyzer:

![glitcher logic analyzer dump]({{site.url}}/ assets/2019-12-08-glitching/glitcher_logic_analyzer.png)

# Troubles
The Olimex board actually runs faster than my FPGA, and in training our FPGA was more than 8 times faster. In practice our successful glitch had a very short pulse, in the tens of cycles (at 100MHz). With a 12MHz clock (I thought) I was in trouble. There is significantly less granularity in pulse widths, and we risk the ideal pulse width between somewhere between a n cycles and (n+1) cycles.

I tried to fix this by using a [PLL](https://en.wikipedia.org/wiki/Phase-locked_loop) which allows you to generate a clock that is faster than the input clock by some multiple. Again, icestorm to the rescue here, I was able to use `icepll` to generate most of the code needed to generate a 48MHz clock from a 12MHz input.

I kept most modules on the main clock, but fed my new `fast_clk` to the pulse. I adjusted my testbench to generate the faster clock and was able to verify that I could generate shorted pulses (with four times the granularity). I actually found a bug in my pulse module here: Since my pulse was running on a clock four times faster than the rest of the system, including the module that enables the pulse, with short width values my pulse was ending _before the enable signal was disabled_. This was causing the pulse module to immediately start a second pulse. I fixed this by adding an extra state to the module that made it wait until after the enable signal was unset before returning to the waiting state.

Unfortunately, when I ran this on real hardware, I found that my pulse width seemed to be consistently the same value. I was unable to debug this and decided to see if I could get the glitch to work without the finer granularity (spoiler: I could).

# Running it in real life
Once I had my simulation looking good, and I was able to see that the behaviour in the real world looked like what I was expecting, it was time to actually glitch the board.

## Modifying the board
To have the CPU misread the lock value we want the voltage to drop at precisely the time when it's reading the appropriate address from flash. Because there are decoupling capacitors on the board, which would smooth out any abrupt voltage change and make this a lot more difficult, I had to remove those capacitors. I also cut traces between the board's voltage regulator and the VCC and VCCIO, so that it's powered exclusively from the output of my analogue multiplexer. This is all well documented in the third part of [Dmitry's blog series](https://toothless.co/blog/bootloader-bypass-part3/#modifying-the-target).

## Determining the supply voltage
Because we unfortunately don't live in a frictionless vacuum where infinitely fast changes in voltage are not possible, even without decoupling capactors, the CPU won't see an instantaneous change in voltage when we toggle `vout`. Because of this, we want to minimize the time the voltage change happens, and so we run the board at the lowest voltage we can find where the board behaves normally.

For me this was 2.30V, which I determined by running a loop where I continuously reset the board and then tried to communicate with the bootloader. I adjusted the voltage on my benchtop supply while this was running until it was just barely high enough to reliably read "Synchronized" after sending the "?" bootloader command.

## The moment of truth
I hooked up the reset line of my FPGA to the reset on the board, hooked up vout to the control pin of the multiplexer, tied `Vglitch` to ground, and then tied `Vcc` to the lowest voltage my board would reliably run at.

![glitcher setup]({{site.url}}/assets/2019-12-08-glitching/glitcher_setup.png)

A friend from work let me borrow his oscilloscope, so I was able to see in real time the reset signal followed by the vout signal pulsing and the corresponding voltage drop in VCC.

![oscilloscope view]({{site.url}}/assets/2019-12-08-glitching/glitcher_scope.jpg)

The yellow line is the reset signal, which is held low for 5uS, and then vout, the cleaner purple signal is toggled _delay_ cycles later, for _pulse width_ cycles. The cyan signal is the actual voltage seen, which we can see is 'dirtier' than the purely logic-level vout signal.

I then ran my script, which brute forced through a range of delay and pulse width values until I was treated to a nice dump of the flash I was not supposed to read! You can see the width of the pulse get wider until it reaches its max, at which point the delay is incremented and the width values are all tried again.

<iframe width="560" height="315" src="https://www.youtube.com/embed/KfGC689I9c0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<iframe width="560" height="315" src="https://www.youtube.com/embed/QyPt-3aLgO8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

And with a certain width and delay our script dumps out the flash!

![glitcher pulse simulation]({{site.url}}/assets/2019-12-08-glitching/glitcher_success.png)

If we look at the lock value, we see that it's what we expect:

![glitcher pulse simulation]({{site.url}}/assets/2019-12-08-glitching/glitcher_lockvalue.png)

We don't see a glitched out value because this dump is _after_ we've glitched the bootloader, with the voltage back at its stable value. At this point in time the bootloader has already (incorrectly) determined that the bootloader is unlocked, and so all subsequent reads succeed.

Of course in real life things didn't go this smoothly, while testing it would I found a bunch of bugs, including how if my delay was too short it would send a pulse while the reset was too low, my pulse width counter had an off-by-one cycle, among other things, so don't worry if you try this and have issues as well: Isolate the issue, make sure your simulation works, compare to real life, and debug.

Obviously I wouldn't have been able to do this without big help from Dmitry, and the friendly people on the 1bitsquared discord. Seriously consider taking Dmitry's training, and if you're looking for your own FPGA board, I can't recommend the iCEBreaker enough!

My code is available on [github](https://github.com/Grazfather/glitcher), heavily based on nedos's [own version](https://github.com/toothlessco/arty-glitcher).
